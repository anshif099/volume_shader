<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
<title>Mali-G720 Only • Fractal Volume Shader (Safe Gate)</title>
<style>
  :root { --fg:#fff; --muted:#aab; --bg:#000; --chip:rgba(255,255,255,.08); }
  html,body{
    margin:0; height:100%; background:var(--bg);
    display:flex; align-items:center; justify-content:center; overflow:hidden;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif; color:var(--fg);
  }
  .stack{ display:flex; flex-direction:column; align-items:center; gap:10px; }
  .chip{
    padding:6px 10px; border-radius:999px; background:var(--chip);
    border:1px solid rgba(255,255,255,.12); backdrop-filter:blur(6px); font-size:13px;
  }
  #canvas{
    width:min(95vmin,900px); height:min(95vmin,900px); display:none; /* shown only on Mali-G720 */
    border-radius:12px; touch-action:none;
  }
  #gpu, #fps, #hint { position:fixed; left:50%; transform:translateX(-50%); }
  #gpu{ top:10px; }
  #hint{ top:40px; color:var(--muted); border-color:transparent; }
  #fps{ bottom:10px; font-family:monospace; }
  #blocked { text-align:center; max-width:90vw; line-height:1.4; display:none; }
  #blocked strong { color:#7dd3ff; }
</style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="gpu" class="chip">GPU: Detecting…</div>
  <div id="hint" class="chip">Touch/drag to rotate • Auto spins • Centered</div>
  <div id="fps" class="chip">FPS: --</div>
  <div id="blocked" class="stack">
    <div class="chip">Fractal disabled</div>
    <div id="blocked-text"></div>
  </div>

<script>
(async function(){
  const gpuEl = document.getElementById('gpu');
  const hintEl = document.getElementById('hint');
  const fpsEl  = document.getElementById('fps');
  const blocked = document.getElementById('blocked');
  const blockedText = document.getElementById('blocked-text');
  const canvas = document.getElementById('canvas');

  // --- Minimal, safe GPU detection (no animation, no shader) ---
  let gpuName = 'Unknown';
  let isMaliG720 = false;
  try{
    const tmpCanvas = document.createElement('canvas');
    const tmpGl = tmpCanvas.getContext('webgl2', {antialias:false});
    if (tmpGl){
      const ext = tmpGl.getExtension('WEBGL_debug_renderer_info');
      gpuName = ext ? tmpGl.getParameter(ext.UNMASKED_RENDERER_WEBGL)
                    : tmpGl.getParameter(tmpGl.RENDERER) || 'Unknown';
      // immediately lose the context reference so browser can GC it
    } else {
      gpuName = 'WebGL2 unavailable';
    }
  }catch(e){
    gpuName = 'Detection error';
  }
  gpuEl.textContent = 'GPU: ' + gpuName;

  // Strict gate: only Mali-G720 passes. Everything else: block & stop.
  isMaliG720 = /Mali[- ]?G720/i.test(gpuName);

  if (!isMaliG720){
    // Do NOT create any long-lived WebGL contexts or rAF loops.
    canvas.style.display = 'none';
    fpsEl.style.display = 'none';
    hintEl.style.display = 'none';
    blocked.style.display = 'flex';
    blockedText.innerHTML =
      'Detected <strong>' + (gpuName || 'Unknown GPU') + '</strong>.<br>' +
      'This demo is <strong>personalized for POCO X7 Pro • Mali-G720</strong> only and is disabled on other GPUs to avoid lag or crashes.';
    gpuEl.style.background = 'rgba(255,64,64,.35)';
    return; // hard stop — nothing else runs
  }

  // If we got here, it’s Mali-G720 — enable canvas + run shader
  canvas.style.display = 'block';
  hintEl.textContent = 'POCO X7 Pro • Mali-G720 • 120 FPS target • Touch/drag to rotate';
  gpuEl.style.background = 'rgba(0,128,255,.35)';

  const gl = canvas.getContext('webgl2', { antialias:false });
  if(!gl){ alert('WebGL2 not supported'); return; }

  function resize(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const size = Math.min(window.innerWidth, window.innerHeight)*0.95;
    canvas.width  = Math.floor(size * dpr);
    canvas.height = Math.floor(size * dpr);
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  const vs=`#version 300 es
  const vec2 pos[3]=vec2[3](vec2(-1,-1),vec2(3,-1),vec2(-1,3));
  void main(){gl_Position=vec4(pos[gl_VertexID],0,1);}
  `;

  const fs=`#version 300 es
  precision highp float;
  out vec4 fragColor;
  uniform vec2 uRes;
  uniform float uTime;
  uniform float uYaw;
  uniform float uPitch;
  vec3 palette(float t){ return 0.5+0.5*cos(6.2831*(vec3(0.0,0.33,0.67)+t)); }
  float mandelbulb(vec3 p,out float trap){
    vec3 z=p; float dr=1.0; float r=0.0; trap=1e9; const float power=8.0;
    for(int i=0;i<10;i++){
      r=length(z); trap=min(trap,r); if(r>2.5)break;
      float theta=acos(z.z/r), phi=atan(z.y,z.x), zr=pow(r,power);
      dr=pow(r,power-1.0)*power*dr+1.0; theta*=power; phi*=power;
      z=zr*vec3(sin(theta)*cos(phi),sin(theta)*sin(phi),cos(theta))+p;
    }
    return 0.5*log(r)*r/dr;
  }
  vec3 getNormal(vec3 p){
    float t; float e=0.0015; vec2 h=vec2(1,-1)*0.5773;
    return normalize(
      h.xyy*mandelbulb(p+h.xyy*e,t)+
      h.yyx*mandelbulb(p+h.yyx*e,t)+
      h.yxy*mandelbulb(p+h.yxy*e,t)+
      h.xxx*mandelbulb(p+h.xxx*e,t)
    );
  }
  void main(){
    vec2 uv=(gl_FragCoord.xy/uRes)*2.0-1.0; uv.x*=uRes.x/uRes.y;
    float time=uTime*0.3;
    float yaw=uYaw + time;
    float pitch=uPitch;
    mat3 rotY=mat3(cos(yaw),0.,-sin(yaw), 0.,1.,0., sin(yaw),0.,cos(yaw));
    mat3 rotX=mat3(1.,0.,0., 0.,cos(pitch),-sin(pitch), 0.,sin(pitch),cos(pitch));
    mat3 cam=rotY*rotX;
    vec3 ro=cam*vec3(0.,0.,2.6);
    vec3 rd=normalize(cam*normalize(vec3(uv,-1.4)));
    float t=0.0; vec3 p; float trap; bool hit=false;
    for(int i=0;i<120;i++){
      p=ro+rd*t; float d=mandelbulb(p,trap);
      if(d<0.001){hit=true;break;} if(t>6.0)break; t+=d*0.9;
    }
    vec3 col=vec3(0.0);
    if(hit){
      vec3 n=getNormal(p);
      vec3 l=normalize(vec3(0.6,0.5,-0.7)); vec3 v=normalize(-rd);
      float diff=max(0.0,dot(n,l));
      float spec=pow(max(dot(reflect(-l,n),v),0.0),32.0);
      float fog=smoothstep(0.0,6.0,length(p));
      vec3 base=palette(trap*0.9);
      col=base*diff*1.2+spec*0.5+base*0.3;
      col=mix(col,vec3(0.02),fog*0.2);
    }
    col=pow(col/(1.0+col),vec3(0.4545));
    fragColor=vec4(col,1.0);
  }`;

  function compile(type,src){
    const sh=gl.createShader(type); gl.shaderSource(sh,src); gl.compileShader(sh);
    if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(sh));
    return sh;
  }
  const prog=gl.createProgram();
  gl.attachShader(prog,compile(gl.VERTEX_SHADER,vs));
  gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,fs));
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog,gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(prog));
  gl.useProgram(prog);

  const uRes=gl.getUniformLocation(prog,'uRes');
  const uTime=gl.getUniformLocation(prog,'uTime');
  const uYaw=gl.getUniformLocation(prog,'uYaw');
  const uPitch=gl.getUniformLocation(prog,'uPitch');
  gl.bindVertexArray(gl.createVertexArray());

  // rotation state (center only; no zoom/pan)
  let yaw=0, pitch=0;
  let dragging=false, sx=0, sy=0;
  canvas.addEventListener('pointerdown',e=>{
    dragging=true; sx=e.clientX; sy=e.clientY; canvas.setPointerCapture(e.pointerId);
  });
  canvas.addEventListener('pointermove',e=>{
    if(!dragging) return;
    const dx=(e.clientX-sx)/canvas.clientWidth;
    const dy=(e.clientY-sy)/canvas.clientHeight;
    yaw   -= dx*3.14159;       // natural left/right
    pitch += dy*1.5;           // up/down
    pitch = Math.max(-1.2, Math.min(1.2, pitch));
    sx=e.clientX; sy=e.clientY;
  }, {passive:true});
  canvas.addEventListener('pointerup',e=>{
    dragging=false; canvas.releasePointerCapture(e.pointerId);
  });
  addEventListener('wheel', e=>e.preventDefault(), {passive:false}); // disable zoom

  function resizeDraw(){
    gl.uniform2f(uRes,canvas.width,canvas.height);
  }
  resizeDraw();

  // Target max refresh (browser decides; your device can be 120Hz)
  let last=performance.now(), ema=null;
  function loop(now){
    const dt=now-last; last=now;
    const fps=1000/dt; ema = ema ? ema*0.9 + fps*0.1 : fps;
    fpsEl.textContent = 'FPS: ' + (ema?ema.toFixed(1):'--');

    gl.uniform1f(uTime, now*0.001);
    gl.uniform1f(uYaw,  yaw);
    gl.uniform1f(uPitch,pitch);
    gl.drawArrays(gl.TRIANGLES,0,3);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>

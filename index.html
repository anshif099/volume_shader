<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Centered Mandelbulb (Rotate Only)</title>
<style>
  :root { --bg:#0a0a0e; --fg:#e8eef6; --glass:rgba(255,255,255,0.06); }
  html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; }
  /* Center the canvas nicely */
  .stage {
    position: fixed; inset: 0;
    display: grid; place-items: center;
  }
  canvas { width:min(96vmin, 1200px); height:min(96vmin, 1200px); display:block; border-radius:16px; }
  header {
    position: fixed; left: 50%; top: 16px; transform: translateX(-50%);
    background: var(--glass); border: 1px solid rgba(255,255,255,0.1);
    padding: 6px 10px; border-radius: 999px; font-size: 13px;
    user-select: none; -webkit-user-select: none;
  }
  #fps { font-variant-numeric: tabular-nums; }
  .hint {
    position: fixed; left: 50%; bottom: 16px; transform: translateX(-50%);
    background: var(--glass); border: 1px solid rgba(255,255,255,0.1);
    padding: 6px 10px; border-radius: 999px; font-size: 12px; opacity:.9;
  }
  a { color:#86e1ff; text-decoration:none; }
</style>
</head>
<body>
  <header>
    <span>Centered Mandelbulb • </span><span id="fps">FPS --</span>
    <span style="opacity:.7"> • drag to rotate</span>
  </header>
  <div class="stage">
    <canvas id="c"></canvas>
  </div>
  <div class="hint">Object is locked at the center. Rotation only (no move/zoom).</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const gl = canvas.getContext('webgl2', { antialias:false, depth:false, stencil:false, alpha:false, preserveDrawingBuffer:false });
  if(!gl){ alert('WebGL2 not supported'); return; }

  // Resize: square canvas, devicePixelRatio-aware
  function resize(){
    const size = Math.min(Math.min(window.innerWidth, window.innerHeight)*0.96, 1200);
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.style.width = size + 'px';
    canvas.style.height = size + 'px';
    canvas.width = Math.max(1, Math.floor(size * dpr));
    canvas.height = Math.max(1, Math.floor(size * dpr));
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  window.addEventListener('resize', resize, { passive:true });

  const vs = `#version 300 es
  const vec2 verts[3]=vec2[3](vec2(-1.,-1.), vec2(3.,-1.), vec2(-1.,3.));
  void main(){ gl_Position = vec4(verts[gl_VertexID], 0., 1.); }`;

  // Mandelbulb distance estimator + soft "volume" via thickness accumulation
  const fs = `#version 300 es
  precision highp float;
  out vec4 fragColor;

  uniform vec2 uRes;
  uniform float uTime;
  uniform mat3 uCamRot;
  uniform vec3 uCamPos;

  // Cosine palette for rainbow colors (matches your image vibe)
  vec3 palette(float t){
    return 0.5 + 0.5*cos(6.28318*(vec3(0.00,0.33,0.67) + t*vec3(1.0,1.0,1.0)));
  }

  // Mandelbulb DE (power 8)
  float mandelbulbDE(vec3 p, out float trap){
    vec3 z = p;
    float dr = 1.0;
    float r = 0.0;
    trap = 1e9;

    const int ITER = 12;
    const float POWER = 8.0;

    for (int i=0; i<ITER; i++){
      r = length(z);
      trap = min(trap, r);
      if (r>2.5) break;

      // Spherical coordinates
      float theta = acos(clamp(z.z / r, -1.0, 1.0));
      float phi   = atan(z.y, z.x);
      float rP = pow(r, POWER);
      dr = pow(r, POWER-1.0)*POWER*dr + 1.0;

      // Scale and rotate
      theta *= POWER;
      phi   *= POWER;

      // Back to cartesian
      z = rP * vec3(
        sin(theta)*cos(phi),
        sin(theta)*sin(phi),
        cos(theta)
      ) + p;
    }
    return 0.5*log(r)*r/dr; // distance estimate
  }

  vec3 estimateNormal(vec3 p){
    float trap;
    float e = 0.0015;
    vec2 h = vec2(1.0, -1.0)*0.5773;
    return normalize(
      h.xyy * mandelbulbDE(p + h.xyy*e, trap) +
      h.yyx * mandelbulbDE(p + h.yyx*e, trap) +
      h.yxy * mandelbulbDE(p + h.yxy*e, trap) +
      h.xxx * mandelbulbDE(p + h.xxx*e, trap)
    );
  }

  // Raymarch to surface
  bool trace(vec3 ro, vec3 rd, out vec3 pos, out float trap, out int steps){
    float t = 0.0;
    steps = 0;
    trap = 0.0;
    for(int i=0;i<128;i++){
      steps = i;
      vec3 p = ro + rd*t;
      float tr;
      float d = mandelbulbDE(p, tr);
      trap = tr;
      if (d<0.001) { pos = p; return true; }
      if (t>6.0) break;
      t += d * 0.9;
    }
    pos = ro + rd*6.0;
    return false;
  }

  void main(){
    vec2 uv = (gl_FragCoord.xy / uRes) * 2.0 - 1.0;
    uv.x *= uRes.x/uRes.y;

    // Camera ray (rotation only; fixed radius)
    vec3 ro = uCamPos;               // fixed distance from origin
    vec3 rd = normalize(uCamRot * normalize(vec3(uv, -1.4)));

    // Ray-sphere kill (optional): helps perf by skipping far miss pixels
    // if(dot(rd, ro) > 0.0 && length(ro) > 2.6) { discard; }

    vec3 p; float trap; int steps;
    bool hit = trace(ro, rd, p, trap, steps);

    vec3 col = vec3(0.0);

    if (hit){
      // Shading
      vec3 N = estimateNormal(p);
      vec3 L = normalize(vec3(0.6, 0.5, -0.7));
      vec3 V = normalize(-rd);

      float diff = max(0.0, dot(N, L));
      float spec = pow(max(0.0, dot(reflect(-L, N), V)), 32.0);

      // Orbit-trap / iteration based coloring
      float t = clamp(trap*0.8, 0.0, 1.0);
      vec3 base = palette(0.15 + t*0.85);

      // Soft fog gives the "volume" feel
      float fog = smoothstep(0.0, 6.0, length(p));
      vec3 ambient = base * 0.35;
      col = ambient + base * diff * 1.1 + spec*0.6;
      col = mix(col, vec3(0.02,0.02,0.03), fog*0.15);

      // Gentle rim light to accent silhouettes
      float rim = pow(1.0 - max(0.0, dot(N, V)), 2.0);
      col += base*rim*0.25;
    } else {
      // Background
      col = vec3(0.0);
    }

    // Tone map & gamma
    col = col/(1.0+col);
    col = pow(col, vec3(0.4545));
    fragColor = vec4(col, 1.0);
  }`;

  function compile(type, src){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(sh));
      throw new Error('Shader compile error.');
    }
    return sh;
  }
  const prog = gl.createProgram();
  gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
  gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(prog));
    throw new Error('Program link error.');
  }
  gl.useProgram(prog);

  const uRes   = gl.getUniformLocation(prog, 'uRes');
  const uTime  = gl.getUniformLocation(prog, 'uTime');
  const uCamRot= gl.getUniformLocation(prog, 'uCamRot');
  const uCamPos= gl.getUniformLocation(prog, 'uCamPos');

  const vao = gl.createVertexArray(); gl.bindVertexArray(vao);

  // Camera state — rotation only, fixed distance
  let yaw = 0.9, pitch = 0.45, dist = 2.4; // fixed
  let dragging = false, px=0, py=0;
  let autoSpin = 0.15; // radians/sec

  canvas.addEventListener('pointerdown', e=>{
    dragging = true; px = e.clientX; py = e.clientY; canvas.setPointerCapture(e.pointerId);
  });
  canvas.addEventListener('pointerup', e=>{
    dragging = false; canvas.releasePointerCapture(e.pointerId);
  });
  canvas.addEventListener('pointermove', e=>{
    if(!dragging) return;
    const dx = (e.clientX - px) / Math.max(1, canvas.clientWidth);
    const dy = (e.clientY - py) / Math.max(1, canvas.clientHeight);
    yaw   += dx * Math.PI * 1.2;
    pitch += dy * Math.PI * 0.8;
    pitch = Math.max(-1.2, Math.min(1.2, pitch));
    px = e.clientX; py = e.clientY;
  }, { passive:true });

  // Disable wheel/pinch zoom completely
  ['wheel','gesturestart','gesturechange','gestureend'].forEach(ev=>{
    window.addEventListener(ev, e=>{ e.preventDefault(); }, { passive:false });
  });

  function camMatrix(yaw, pitch){
    const cy=Math.cos(yaw), sy=Math.sin(yaw);
    const cp=Math.cos(pitch), sp=Math.sin(pitch);
    // Yaw then pitch (right-handed)
    return new Float32Array([
      cy,    0,   -sy,
      sy*sp, cp,  cy*sp,
      sy*cp, -sp, cy*cp
    ]);
  }

  function camPosition(yaw, pitch, dist){
    const R = camMatrix(yaw, pitch);
    // camera is back along forward axis
    return new Float32Array([ R[2]*dist, R[5]*dist, R[8]*dist ]);
  }

  // Timing & FPS
  let t0 = performance.now();
  let ema = null;
  function fps(dt){
    const f = 1000/dt;
    ema = (ema===null)? f : (ema*0.9 + f*0.1);
    document.getElementById('fps').textContent = 'FPS ' + ema.toFixed(1);
  }

  function draw(now){
    const dt = now - t0; t0 = now;
    resize();

    // Auto-rotate when not dragging
    if(!dragging) yaw += autoSpin * (dt/1000);

    const R = camMatrix(yaw, pitch);
    const P = camPosition(yaw, pitch, dist);

    gl.useProgram(prog);
    gl.uniform2f(uRes, canvas.width, canvas.height);
    gl.uniform1f(uTime, now*0.001);
    gl.uniformMatrix3fv(uCamRot, false, R);
    gl.uniform3fv(uCamPos, P);

    gl.bindVertexArray(vao);
    gl.drawArrays(gl.TRIANGLES, 0, 3);

    fps(dt);
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
